# Optical Fiber Simulation

This Python library provides a set of measured values, methods, and classes for the simulation of polarization mode dispersion in optical fibers.

Specifically, the ``fibers.py`` module provides the following classes (see their individual documentations for more details):

* ``FiberLength``, the base class that stores information about the fiber geometry and conditions and calculates birefringences and Jones matrices;
* ``FiberPaddleSet``, a set of fiber paddles like ThorLabs FPC563 that manually controls the polarization;
* ``Rotator``, providing arbitrary rotations; and
* ``Fiber``, an implementation of the hinge model of optical fibers that alternates hinges with long birefringent sections. This class includes the ``Fiber.random()`` method for generating random optical fibers following user specifications.

This repository also includes the example Jupyter notebook for getting started.

The lbirary requires NumPy; you may also find ``py_pol`` and ``plotly`` useful, as detailed below. The last example in the example notebook requires SciPy and MatPlotLib.

### Using ``py_pol`` (and Some Caveats)

To aid in understanding the results of these simulations, I've found it best to use the package [``py_pol``](https://mail.google.com/mail/u/0/#inbox). The example Jupyter notebook shows a few examples of the use of this package, especially translating the Jones matrices generated by this package to Mueller matrices and Stokes vectors.

I have been especially interested in putting two sets of simulation results on the same Poincar√© sphere. As best I can tell this is not supported in ``py_pol``, but there is a quick and dirty fix: install ``plotly`` in your environment, and in the ``drawings.py`` file of your local install of ``py_pol``, in the ``draw_poincare()`` method, set ``add_auxiliar = True`` by default on line 523. Then use code like I show in the examples notebook.

Another annoying caveat: one of the reasons ``py_pol`` is convenient is you can pass multiple objects around at the same time, e.g. ``E1 = J0 * E0`` can represent the several Jones vectors resulting from one Jones vector ``E0`` being multiplied by several Jones matrices ``J0``. However, this fails if there are exactly two Jones matrices in ``J0.`` So be wary of trying to make direct comparisons between two Jones matrices.
