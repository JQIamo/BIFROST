# BIFROST — Birefringence In Fiber: Research and Optical Simulation Toolkit

BIFROST is a Python library that provides a set of data, methods, and classes for the simulation of polarization mode dispersion in optical fibers. Silica-based fibers whose core and/or cladding are doped with germanium oxide or with fluorine can be simulated.

Specifically, the ``fibers.py`` module provides the following classes (see their individual documentations for more details):

* ``FiberLength``, the base class that stores information about the fiber geometry and conditions and calculates birefringences and Jones matrices;
* ``FiberPaddleSet``, a set of fiber paddles like ThorLabs FPC563 that manually controls the polarization;
* ``Rotator``, providing arbitrary rotations; and
* ``Fiber``, an implementation of the hinge model of optical fibers that alternates hinges with long birefringent sections. This class includes the ``Fiber.random()`` method for generating random optical fibers following user specifications.

This repository also includes the example Jupyter notebook for getting started.

The library requires NumPy; you may also find ``py_pol`` and ``plotly`` useful, as detailed below. The last example in the example notebook requires SciPy and MatPlotLib.

### Using ``py_pol`` (and Some Caveats)

To aid in understanding the results of these simulations, I've found it best to use the package [``py_pol``](https://mail.google.com/mail/u/0/#inbox). The example Jupyter notebook shows a few examples of the use of this package, especially translating the Jones matrices generated by this package to Mueller matrices and Stokes vectors.

I have been especially interested in putting two sets of simulation results on the same Poincaré sphere. As best I can tell this is not supported in ``py_pol``, but there is a quick and dirty fix: install ``plotly`` in your environment, and in the ``drawings.py`` file of your local install of ``py_pol``, in the ``draw_poincare()`` method, set ``add_auxiliar = True`` by default on line 523. Then use code like I show in the examples notebook.

Another annoying caveat: one of the reasons ``py_pol`` is convenient is you can pass multiple objects around at the same time, e.g. ``E1 = J0 * E0`` can represent the several Jones vectors resulting from one Jones vector ``E0`` being multiplied by several Jones matrices ``J0``. However, this fails if there are exactly two Jones matrices in ``J0.`` So be wary of trying to make direct comparisons between two Jones matrices.

### License

Copyright (C) 2025 Patrick Banner.

This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
